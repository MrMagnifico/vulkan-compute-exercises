#version 450

// The first buffer (uniform) provides the conifg: width, height
layout (set = 0, binding = 0) uniform ConfigBuffer {
	uint width;
	uint height;
} config;

// The second buffer (storage) provides the input image
layout (set = 0, binding = 1) buffer ImageIn {
	uint rgba[];
} incoming;

// The third buffer (storage) provides the output image
layout (set = 0, binding = 2) buffer ImageOut {
	uint rgba[];
} outgoing;

// Compresses a vec4 with colors in range [0, 1] to 256-color RGBA
uint compress(vec4 rgba) {
	uint result;
	rgba 	= clamp(rgba, 0, 1);
	result 	= uint(rgba.r * 255.0f);
	result 	|= uint(rgba.g * 255.0f) << 8;
	result 	|= uint(rgba.b * 255.0f) << 16;
	result	|= uint(rgba.a * 255.0f) << 24;
	return result;
}

// Decompresses 256-color RGBA into a vec4 with colors in range [0, 1]
vec4 decompress(uint rgba) {
	vec4 result;
	result.r = (rgba & 0xff) / 255.0f;
	result.g = ((rgba >> 8) & 0xff) / 255.0f;
	result.b = ((rgba >> 16) & 0xff) / 255.0f;
	result.a = ((rgba >> 24) & 0xff) / 255.0f;
	return result;
}

uint imageBufferOffset(int x, int y) { return x + (y * config.width); }

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main() {
	// Get this thread's pixel location
	const int x = int(gl_GlobalInvocationID.x);
	const int y = int(gl_GlobalInvocationID.y);
	
	// Threads that would read/write outside the image should stop
	if (x >= config.width || y >= config.height) { return; }

	// The Sobel filter to use in both X and Y direction
	// https://en.wikipedia.org/wiki/Sobel_operator
	const float sobel[3][3] = {{1, 0, -1},
							   {2, 0, -2},
							   {1, 0, -1}};

	// Summed RGBA filter results.
	vec4 Gx = vec4(0, 0, 0, 1);
	vec4 Gy = vec4(0, 0, 0, 1);

	// TODO: Compute the linear index of this thread's pixel location in the
	// image. Iterate over a 3x3 2D window around the thread's pixel location.
	// For this, make sure you don't read outside the image: clamp the reading
	// coordinates to 0 from below, and to width - 1 from above for X,
	// and to height - 1 from above for Y. Read the compressed integer value
	// at the corresponding location from the input image, and use decompress 
	// to turn it into a vec4 with RGBA in range [0, 1]. Multiply it with the 
	// appropriate weight from the given Sobel filter to do detection of 
	// horizontal lines and accumulate the result in Gx. Do the same for 
	// detection of vertical lines and store the result in Gy. 
	// 
	// When you processed the whole window, take the absolute values of Gx and Gy
	// and add them together. Compress the result and write it to this thread's 
	// linear pixel index in the output image. 
	//
	// Hint: If you are unsure about indexing and reading/writing locations, before 
	// implementing your solution, maybe experiment a bit with writing values like 
	// compress(vec4(1, 0, 0, 1)) to different locations and see what that does.

	// Compute gradient estimates
	const uint bufferOffset = imageBufferOffset(x, y);
	for (int xOffset = -1; xOffset <= 1; xOffset++) {
		int xNeighbor = x + xOffset;
		if (xNeighbor < 0 || xNeighbor >= config.width) { continue; }
		for (int yOffset = -1; yOffset <= 1; yOffset++) {
			int yNeighbor = y + yOffset;
			if (yNeighbor < 0 || yNeighbor >= config.height) { continue; }

			float sobelX				= sobel[yOffset + 1][xOffset + 1];
			float sobelY				= sobel[xOffset + 1][yOffset + 1];
			uint bufferOffsetNeighbor	= imageBufferOffset(xNeighbor, yNeighbor);
			vec4 neighborDecomp			= decompress(incoming.rgba[bufferOffsetNeighbor]);
			Gx							+= sobelX * neighborDecomp;
			Gy							+= sobelY * neighborDecomp;
		}
	}

	// Write estimated gradient magnitude
	vec4 gradientMagnitude		= sqrt((Gx * Gx) + (Gy * Gy));
	outgoing.rgba[bufferOffset]	= compress(gradientMagnitude);
}
