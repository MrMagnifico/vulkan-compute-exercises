#version 450

#extension GL_EXT_debug_printf : require // Require printf support for print statement debugging

// TODO: List all necessary resources and implement the matrix multiplication
// shader. Also pick an adequate work group size for the problem.

#define LOCAL_SIZE 32 // Threads are organised in (LOCAL_SIZE x LOCAL_SIZE) blocks

struct MatrixInfo {
	uint width;
    uint height;
    uint stride;
};

layout (std430, set = 0, binding = 0) buffer MatrixA {
    MatrixInfo info;
    float data[];
} matA;

layout (std430, set = 0, binding = 1) buffer MatrixB {
    MatrixInfo info;
    float data[];
} matB;

layout (std430, set = 0, binding = 2) buffer MatrixC {
    MatrixInfo info;
    float data[];
} matC;


void debugPrintInput() {
    uint idX = gl_GlobalInvocationID.x;
    uint idY = gl_GlobalInvocationID.y;
    if (idX == 0 && idY == 0) {
        debugPrintfEXT("=== Matrix A ===\n");
        debugPrintfEXT("W: %d H: %d S: %d\n", matA.info.width, matA.info.height, matA.info.stride);
        debugPrintfEXT("R0C1: %f\n", matA.data[1]);
        debugPrintfEXT("=== Matrix B ===\n");
        debugPrintfEXT("W: %d H: %d S: %d\n", matB.info.width, matB.info.height, matB.info.stride);
        debugPrintfEXT("R0C1: %f\n", matB.data[1]);
        debugPrintfEXT("=== Matrix C ===\n");
        debugPrintfEXT("R0C1: %f\n", matC.data[1]);
        debugPrintfEXT("W: %d H: %d S: %d\n", matC.info.width, matC.info.height, matC.info.stride);
    }
}

float memOffset(const MatrixInfo matInfo, int row, int col) { return row * matInfo.stride + col; }

layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;
void main() {
    debugPrintInput(); // TODO: Remove
}
